Descrição da solução:

 * linguagem utilizada
O grupo decidiu usar a linguagem C++ para a resolução deste problema, por produzir executáveis de rápida execução, por ter uma boa biblioteca de estruturas de dados que considerou necessário e ainda por constituir um desafio começar a trabalhar com uma nova linguagem, tão usada e potente nos dias de hoje.

 * desenvolvimento da solução
Começámos por desenhar um algoritmo que identificava as pontes (cut edges) do grafo, uma vez que, removendo os vértices que constituíssem esse arco, obteríamos um sub-grafo não conexo. Teríamos especial atenção aos vértices que formassem uma ponte que apenas tivessem uma aresta, pois a sua remoção não aumentaria o número de sub-grafos da @!rede. Esta abordagem não contempla os vértices de articulação que não formam pontes (Figura 1)Em aula teórica e com alguma pesquisa na internet, aprendemos que o algoritmo de pesquisa de Tarjan (DFS) permite encontrar os pontos de articulação dos grafos [referir a webgrafia, tipo com um "[1]"]. Como esse algoritmo executauma DFS, seria ainda possível calcular imediatamente o número de sub-redes do grafo, ao calcular a floresta DFS(?) e, ao percorrer todos os vértices, um por cada sub-rede, seria ainda possível identificar o seu vértice com o maior id.[EXPLICAR TEORICAMENTE / INTUITIVAMENTE ALGORITMO DE TARJAN?]Notámos ainda que se executarmos a primeira DFS a começar pelos vértices de maior número, o vértice inicial será inevitavelmente o maior vértice desse subgrafo. Para além disso, à medida que se for explorando as várias árvores DFS, o número do maior vértice de cada árvore vai inevitavelmente decrescer. Assim, executando uma DFS e guardando os vértices iniciais de cada chamada recursiva por ordem inversa, obtemos imediatamente uma sequência ordenada dos vértices com maior id de cada subrede.Resta finalmente calcular o número de vértices do maior subgrafo resultante da remoção de todos os vértices críticos encontrados.Inicialmente pensámos em(, literalmente, ?) remover todos os vértices de articulação e todas as arestas para estes. Rapidamente nos apercebemos que seria uma solução demasiado cara para o efeito, que podia ser feito ao saber de antemão quais dos vértices são críticos e ignorá-los numa última DFS feita.

 * representação do grafo
Como neste algoritmo apenas será preciso inserir arestas e iterar todas as adjacências dos vértices de seguida, optámos por poupar em memória e representar o grafo usando uma lista de adjacências. Uma lista simplesmente ligada para representar as adjacências de cadavértice permite uma inserção constante e não é problemática pois não será necessário efetuar pesquisas nela (apenas vai ser iterada).


 * porque das estruturas usadas
Para efetuarmos eficientemente o algoritmo precisámos de guardar flags informativas para os vértices. Como eles têm id's numéricos, essas informações podem ser guardadas em vetores e diretamente acedidas, com um baixo custo de memória (a informação teria de ser guardada de qualquer das maneiras). Preferimos guardar esses vetores na stack, para não termos de efetuar chamadas de sistema, que são mais lentas. Contudo, para inputs muito grandes, a stack não é suficientemente grande, pelo que tivemos de guardar um desses vetores na heap, usando a chamada de sistema malloc.

 * explicação da solução final


Bibliografia:
slides da aula? (true, mas kinda graxa...)
https://www.geeksforgeeks.org/articulation-points-or-cut-vertices-in-a-graph/



TODO:
	Usar matematiquês (usar os termos de grafos)
	Corrigir uso de conceitos do problema (rede, routers, etc) [?]
